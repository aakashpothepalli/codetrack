import React from 'react'


export let primeFactorization2 =  (  
        <div>
        <h4>Note: The below topics are quite advanced, you may skip them for now </h4>
    
    
        <h2 className="code-line" data-line-start={125} data-line-end={126}><a id="Fermats_factorization_method_125" />Fermat’s factorization method</h2>
        <p className="has-line-data" data-line-start={127} data-line-end={131}>We can write an odd composite number $n = p \cdot q$ as the difference of two squares $n = a^2 - b^2$:<br />
          <div> $$$$$$n = \left(\frac{'{'}p + q{'}'}{'{'}2{'}'}\right)^2 - \left(\frac{'{'}p - q{'}'}{'{'}2{'}'}\right)^2$$$$$$</div>
          Fermat’s factorization method tries to exploit the fact, by guessing the first square $a^2$, and check if the remaining part $b^2 = a^2 - n$ is also a square number.<br />
          If it is, then we have found the factors $a - b$ and $a + b$ of $n$.</p>
        <pre><code className="has-line-data" data-line-start={133} data-line-end={145}><span className="hljs-function"><span className="hljs-keyword">int</span> <span className="hljs-title">fermat</span><span className="hljs-params">(<span className="hljs-keyword">int</span> n)</span> </span>{"{"}{"\n"}{"    "}<span className="hljs-keyword">int</span> a = <span className="hljs-built_in">ceil</span>(<span className="hljs-built_in">sqrt</span>(n));{"\n"}{"    "}<span className="hljs-keyword">int</span> b2 = a*a - n;{"\n"}{"    "}<span className="hljs-keyword">int</span> b = round(<span className="hljs-built_in">sqrt</span>(b2));{"\n"}{"    "}<span className="hljs-keyword">while</span> (b * b != b2) {"{"}{"\n"}{"        "}a = a + <span className="hljs-number">1</span>;{"\n"}{"        "}b2 = a*a - n;{"\n"}{"        "}b = round(<span className="hljs-built_in">sqrt</span>(b2));{"\n"}{"    "}{"}"}{"\n"}{"    "}<span className="hljs-keyword">return</span> a - b;{"\n"}{"}"}{"\n"}</code></pre>
        <p className="has-line-data" data-line-start={146} data-line-end={149}>Notice, this factorization method can be very fast, if the difference between the two factors $p$ and $q$ is small.<br />
          The algorithm runs in $O(|p - q|)$ time.<br />
          However since it is very slow, once the factors are far apart, it is rarely used in practice.</p>
        <p className="has-line-data" data-line-start={150} data-line-end={152}>However there are still a huge number of optimizations for this approach.<br />
          E.g. by looking at the squares $a^2$ modulo a fixed small number, you can notice that you don’t have to look at certain values $a$ since they cannot produce a square number $a^2 - n$.</p>
        
        
        {/* <h2 className="code-line" data-line-start={154} data-line-end={155}><a id="Pollards_p__1_method_154" />Pollard’s $p - 1$ method</h2> */}
        {/* <p className="has-line-data" data-line-start={156} data-line-end={161}>It is very likely that at least one factor of a number is $B$<strong>-powersmooth</strong> for small $B$.<br /> */}
          {/* $B$-powersmooth means, that every power $d^k$ of a prime $d$ that divides $p-1$ is at most $B$.<br /> */}
          {/* E.g. the prime factorization of $4817191$ are is $1303 \cdot 3697$.<br /> */}
          {/* And the factors are $31$-powersmooth and $16$-powersmooth respectably, because $1303 - 1 = 2 \cdot 3 \cdot 7 \cdot 31$ and $3697 - 1 = 2^4 \cdot 3 \cdot 7 \cdot 11$.<br /> */}
          {/* In 1974 John Pollard invented a method to extracts $B$-powersmooth factors from a composite number.</p> */}
        {/* <p className="has-line-data" data-line-start={162} data-line-end={165}>The idea comes from <a href="./algebra/phi-function.html#application">Fermat’s little theorem</a>.<br /> */}
          {/* Let a factorization of $n$ be $n = p \cdot q$.<br /> */}
          {/* It says that if $a$ is coprime t/o $p$, the following statement holds:</p> */}
        {/* <p className="has-line-data" data-line-start={166} data-line-end={167}><span className="math inline"><span className="katex"><span className="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mo><mo>(</mo><mo>mod</mo><mspace width="0.333333em" /><mi>p</mi><mo>)</mo></mo></mrow><annotation encoding="application/x-tex">a^{'{'}p - 1{'}'} \equiv 1 \pmod{'{'}p{'}'}</annotation></semantics></math></span><span className="katex-html" aria-hidden="true"><span className="strut" style={{height: '0.8141079999999999em'}} /><span className="strut bottom" style={{height: '1.064108em', verticalAlign: '-0.25em'}} /><span className="base"><span className="mord"><span className="mord mathit">a</span><span className="msupsub"><span className="vlist-t"><span className="vlist-r"><span className="vlist" style={{height: '0.8141079999999999em'}}><span style={{top: '-3.063em', marginRight: '0.05em'}}><span className="pstrut" style={{height: '2.7em'}} /><span className="sizing reset-size6 size3 mtight"><span className="mord mtight"><span className="mord mathit mtight">p</span><span className="mbin mtight">−</span><span className="mord mtight">1</span></span></span></span></span></span></span></span></span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mrel">≡</span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mord">1</span><span className="mspace eightmuspace" />(mod<span className="mspace sixmuspace" /><span className="mord mathit">p</span>)</span></span></span></span></p> */}
        {/* <p className="has-line-data" data-line-star/t={168} data-line-end={169}>This also means that</p> */}
        {/* <p className="has-line-data" data-line-start={170} data-line-end={171}><span className="math inline"><span className="katex"><span className="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>k</mi></msup></mrow></msup><mo>≡</mo><msup><mi>a</mi><mrow><mi>k</mi><mo>⋅</mo><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mo><mo>(</mo><mo>mod</mo><mspace width="0.333333em" /><mi>p</mi><mo>)</mo></mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">a^{'{'}(p - 1)^k{'}'} \equiv a^{'{'}k \cdot (p - 1){'}'} \equiv 1 \pmod{'{'}p{'}'}.</annotation></semantics></math></span><span className="katex-html" aria-hidden="true"><span className="strut" style={{height: '1.0119199999999997em'}} /><span className="strut bottom" style={{height: '1.2619199999999997em', verticalAlign: '-0.25em'}} /><span className="base"><span className="mord"><span className="mord mathit">a</span><span className="msupsub"><span className="vlist-t"><span className="vlist-r"><span className="vlist" style={{height: '1.0119199999999997em'}}><span style={{top: '-3.063em', marginRight: '0.05em'}}><span className="pstrut" style={{height: '2.7em'}} /><span className="sizing reset-size6 size3 mtight"><span className="mord mtight"><span className="mopen mtight">(</span><span className="mord mathit mtight">p</span><span className="mbin mtight">−</span><span className="mord mtight">1</span><span className="mclose mtight"><span className="mclose mtight">)</span><span className="msupsub"><span className="vlist-t"><span className="vlist-r"><span className="vlist" style={{height: '0.9270285714285713em'}}><span style={{top: '-2.931em', marginRight: '0.07142857142857144em'}}><span className="pstrut" style={{height: '2.5em'}} /><span className="sizing reset-size3 size1 mtight"><span className="mord mathit mtight" style={{marginRight: '0.03148em'}}>k</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mrel">≡</span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mord"><span className="mord mathit">a</span><span className="msupsub"><span className="vlist-t"><span className="vlist-r"><span className="vlist" style={{height: '0.8879999999999999em'}}><span style={{top: '-3.063em', marginRight: '0.05em'}}><span className="pstrut" style={{height: '2.7em'}} /><span className="sizing reset-size6 size3 mtight"><span className="mord mtight"><span className="mord mathit mtight" style={{marginRight: '0.03148em'}}>k</span><span className="mbin mtight">⋅</span><span className="mopen mtight">(</span><span className="mord mathit mtight">p</span><span className="mbin mtight">−</span><span className="mord mtight">1</span><span className="mclose mtight">)</span></span></span></span></span></span></span></span></span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mrel">≡</span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mord">1</span><span className="mspace eightmuspace" />(mod<span className="mspace sixmuspace" /><span className="mord mathit">p</span>)<span className="mord">.</span></span></span></span></span></p> */}
        {/* <p className="has-line-data" data-line-start={172} data-line-end={174}>So for any $M$ with $p - 1 <sub>|</sub> M$ we know that $a^M \equiv 1$.<br /> */}
          {/* This means that $a^M - 1 = p \cdot r$, and because of that also $p <sub>|</sub> \gcd(a^M - 1, n)$.</p> */}
        {/* <p className="has-line-data" data-line-start={175} data-line-end={176}>Therefore, if $p - 1$ for a factor $p$ of $n$ divides $M$, we can extract a factor using <a href="./algebra/euclid-algorithm.html">Euclid’s algorithm</a>.</p> */}
        {/* <p className="has-line-data" data-line-start={177} data-line-end={180}>It is clear, that the smallest $M$ that is a multiple of every $B$-powersmooth number is $\text{'{'}lcm{'}'}(1,<sub>2</sub>,3~,4~,<sub>\dots,</sub>B)$.<br /> */}
          {/* Or alternatively:<br /> */}
          {/* <span className="math inline"><span className="katex"><span className="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>=</mo><msub><mo>∏</mo><mrow><mtext>prime </mtext><mi>q</mi><mo>≤</mo><mi>B</mi></mrow></msub><msup><mi>q</mi><mrow><mo>⌊</mo><msub><mi>log</mi><mo>⁡</mo><mi>q</mi></msub><mi>B</mi><mo>⌋</mo></mrow></msup></mrow><annotation encoding="application/x-tex">M = \prod_{'{'}\text{'{'}prime {'}'} q \le B{'}'} q^{'{'}\lfloor \log_q B \rfloor{'}'}</annotation></semantics></math></span><span className="katex-html" aria-hidden="true"><span className="strut" style={{height: '0.916078em'}} /><span className="strut bottom" style={{height: '1.351896em', verticalAlign: '-0.43581800000000004em'}} /><span className="base"><span className="mord mathit" style={{marginRight: '0.10903em'}}>M</span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mrel">=</span><span className="mord rule" style={{marginRight: '0.2777777777777778em'}} /><span className="mop"><span className="mop op-symbol small-op" style={{position: 'relative', top: '-0.0000050000000000050004em'}}>∏</span><span className="msupsub"><span className="vlist-t vlist-t2"><span className="vlist-r"><span className="vlist" style={{height: '0.17862099999999992em'}}><span style={{top: '-2.40029em', marginLeft: '0em', marginRight: '0.05em'}}><span className="pstrut" style={{height: '2.7em'}} /><span className="sizing reset-size6 size3 mtight"><span className="mord mtight"><span className="mord text mtight"><span className="mord mtight">prime </span></span><span className="mord mathit mtight" style={{marginRight: '0.03588em'}}>q</span><span className="mrel mtight">≤</span><span className="mord mathit mtight" style={{marginRight: '0.05017em'}}>B</span></span></span></span></span><span className="vlist-s">​</span></span><span className="vlist-r"><span className="vlist" style={{height: '0.43581800000000004em'}} /></span></span></span></span><span className="mord rule" style={{marginRight: '0.16666666666666666em'}} /><span className="mord"><span className="mord mathit" style={{marginRight: '0.03588em'}}>q</span><span className="msupsub"><span className="vlist-t"><span className="vlist-r"><span className="vlist" style={{height: '0.916078em'}}><span style={{top: '-3.0910780000000004em', marginRight: '0.05em'}}><span className="pstrut" style={{height: '2.7em'}} /><span className="sizing reset-size6 size3 mtight"><span className="mord mtight"><span className="mopen mtight">⌊</span><span className="mop mtight"><span className="mop mtight">lo<span style={{marginRight: '0.01389em'}}>g</span></span><span className="msupsub"><span className="vlist-t vlist-t2"><span className="vlist-r"><span className="vlist" style={{height: '0.04167428571428572em'}}><span style={{top: '-2.2341314285714287em', marginRight: '0.07142857142857144em'}}><span className="pstrut" style={{height: '2.5em'}} /><span className="sizing reset-size3 size1 mtight"><span className="mord mathit mtight" style={{marginRight: '0.03588em'}}>q</span></span></span></span><span className="vlist-s">​</span></span><span className="vlist-r"><span className="vlist" style={{height: '0.40475428571428573em'}} /></span></span></span></span><span className="mord rule mtight" style={{marginRight: '0.19516666666666668em'}} /><span className="mord mathit mtight" style={{marginRight: '0.05017em'}}>B</span><span className="mclose mtight">⌋</span></span></span></span></span></span></span></span></span></span></span></span></span></p> */}
        {/* <p className="has-line-data" data-line-start={181} data-line-end={184}>Notice, if $p-1$ divides $M$ for all prime factors $p$ of $n$, then $\gcd(a^M - 1, n)$ will just be $n$.<br /> */}
          {/* In this case we don’t receive a factor.<br /> */}
          {/* Therefore we will try to perform the $\gcd$ multiple time, while we compute $M$.</p> */}
        {/* <p className="has-line-data" data-line-start={185} data-line-end={188}>Some composite numbers don’t have $B$-powersmooth factors for small $B$.<br /> */}
          {/* E.g. the factors of the composite number $100.000.000.000.000.493 = 763.013 \cdot 131.059.365.961$ are $190.753$-powersmooth and $1092161383$-powersmooth.<br /> */}
          {/* We would have to choose $B &gt;= 190.753$ to factorize the number.</p> */}
        {/* <p className="has-line-data" data-line-start={189} data-line-end={190}>In the following implementation we start with $B = 10$ and increase $B$ after each each iteration.</p> */}
        {/* <pre><code className="has-line-data" data-line-start={192} data-line-end={220}><span className="hljs-function"><span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> <span className="hljs-title">pollards_p_minus_1</span><span className="hljs-params">(<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> n)</span> </span>{"{"}{"\n"}{"    "}<span className="hljs-keyword">int</span> B = <span className="hljs-number">10</span>;{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> g = <span className="hljs-number">1</span>;{"\n"}{"    "}<span className="hljs-keyword">while</span> (B &lt;= <span className="hljs-number">1000000</span> &amp;&amp; g &lt; n) {"{"}{"\n"}{"        "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> a = <span className="hljs-number">2</span> + rand() %{"  "}(n - <span className="hljs-number">3</span>);{"\n"}{"        "}g = gcd(a, n);{"\n"}{"        "}<span className="hljs-keyword">if</span> (g &gt; <span className="hljs-number">1</span>){"\n"}{"            "}<span className="hljs-keyword">return</span> g;{"\n"}{"\n"}{"        "}<span className="hljs-comment">// compute a^M</span>{"\n"}{"        "}<span className="hljs-keyword">for</span> (<span className="hljs-keyword">int</span> p : primes) {"{"}{"\n"}{"            "}<span className="hljs-keyword">if</span> (p &gt;= B){"\n"}{"                "}<span className="hljs-keyword">continue</span>;{"\n"}{"            "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> p_power = <span className="hljs-number">1</span>;{"\n"}{"            "}<span className="hljs-keyword">while</span> (p_power * p &lt;= B){"\n"}{"                "}p_power *= p;{"\n"}{"            "}a = power(a, p_power, n);{"\n"}{"\n"}{"            "}g = gcd(a - <span className="hljs-number">1</span>, n);{"\n"}{"            "}<span className="hljs-keyword">if</span> (g &gt; <span className="hljs-number">1</span> &amp;&amp; g &lt; n){"\n"}{"                "}<span className="hljs-keyword">return</span> g;{"\n"}{"        "}{"}"}{"\n"}{"        "}B *= <span className="hljs-number">2</span>;{"\n"}{"    "}{"}"}{"\n"}{"    "}<span className="hljs-keyword">return</span> <span className="hljs-number">1</span>;{"\n"}{"}"}{"\n"}{"\n"}</code></pre> */}
        {/* <p className="has-line-data" data-line-start={221} data-line-end={223}>Notice, this is a probabilistic algorithm.<br /> */}
          {/* It can happen that the algorithm doesn’t find a factor.</p> */}
        {/* <p className="has-line-data" data-line-start={224} data-line-end={225}>The complexity is $O(B \log B \log^2 n)$ per iteration.</p> */}
    
        <h2 className="code-line" data-line-start={226} data-line-end={227}><a id="Pollards_rho_algorithm_226" />Pollard’s rho algorithm</h2>
        <p className="has-line-data" data-line-start={228} data-line-end={229}>Another factorization algorithm from John Pollard.</p>
        <p className="has-line-data" data-line-start={230} data-line-end={232}>Let the prime factorization from a number be $n = p q$.<br />
          The algorithm look at a pseudo-random sequence $&#123;x_i&#125; = &#123;x_0,~f(x_0),~f(f(x_0)),~\dots&#125;$ where $f$ is a polynomial function, usually $f(x) = x^2 + c \bmod n$ is chosen with $c = 1$.</p>
        <p className="has-line-data" data-line-start={233} data-line-end={237}>Actually we are not very interested in the sequence ${'{'}x_i{'}'}$, we are more interested in the sequence ${'{'}x_i \bmod p{'}'}$.<br />
          Since $f$ is a polynomial function and all the values are in the range $[0;~p)$ this sequence will begin to cycle sooner or later.<br />
          The <strong>birthday paradox</strong> actually suggests, that the expected number of elements is $O(\sqrt{'{'}p{'}'})$ until the repetition starts.<br />
          If $p$ is smaller than $\sqrt{'{'}n{'}'}$, the repetition will start very likely in $O(\sqrt[4]{'{'}n{'}'})$.</p>
        <p className="has-line-data" data-line-start={238} data-line-end={240}>Here is a visualization of such a sequence ${'{'}x_i \bmod p{'}'}$ with $n = 2206637$, $p = 317$, $x_0 = 2$ and $f(x) = x^2 + 1$.<br />
          From the form of the sequence you can see very clearly why the algorithm is called Pollard’s $\rho$ algorithm.</p>
        <p className="has-line-data" data-line-start={241} data-line-end={242}><img src="https://raw.githubusercontent.com/e-maxx-eng/e-maxx-eng/master/img/pollard_rho.png" alt="Pollard's rho visualization" /></p>
        <p className="has-line-data" data-line-start={243} data-line-end={245}>There is still one big open question.<br />
          We don’t know $p$ yet, so how can we argue about the sequence ${'{'}x_i \bmod p{'}'}$?</p>
        <p className="has-line-data" data-line-start={246} data-line-end={249}>It’s actually quite easy.<br />
          There is a cycle in the sequence $\{'{'}x_i \bmod p\{'}'}_{'{'}i \le j{'}'}$ if and only if there are two indices $s, t \le j$ and $t$ with $x_s \equiv x_t \bmod p$.<br />
          This equation can be rewritten as $x_s - x_t \equiv 0 \bmod p$ which is the same as $p ~|~ \gcd(x_s - x_t, n)$</p>
        <p className="has-line-data" data-line-start={250} data-line-end={253}>Therefore, if we find two indices $s$ and $t$ with $g = \gcd(x_s - x_t, n) &gt; 1$, we have found a cycle and also a factor $g$ of $n$.<br />
          Notice that it is possible that $g = n$.<br />
          In this case we haven’t found a proper factor, and we have to repeat the algorithm with different parameter (different starting value $x_0$, different constant $c$ in the polynomial function $f$).</p>
        <p className="has-line-data" data-line-start={254} data-line-end={255}>To find the cycle, we can use any common cycle detection algorithm.</p>
        <h3 className="code-line" data-line-start={256} data-line-end={257}><a id="Floyds_cyclefinding_algorithm_256" />Floyd’s cycle-finding algorithm</h3>
        <p className="has-line-data" data-line-start={258} data-line-end={263}>This algorithm finds a cycle by using two pointer.<br />
          These pointers move over the sequence at different speeds.<br />
          In each iteration the first pointer advances to the next element, but the second pointer advances two elements.<br />
          It’s not hard to see, that if there exists a cycle, the second pointer will make at least one full cycle and then meet the first pointer during the next few cycle loops.<br />
          If the cycle length is $\lambda$ and the $\mu$ is the first index at which the cycle starts, then the algorithm will run in $O(\lambda + \mu)$ time.</p>
        <p className="has-line-data" data-line-start={264} data-line-end={265}>This algorithm is also known as <strong>tortoise and the hare algorithm</strong>, based on the tale in which a tortoise (here a slow pointer) and a hare (here a faster pointer) make a race.</p>
        <p className="has-line-data" data-line-start={266} data-line-end={270}>It is actually possible to determine the parameter $\lambda$ and $\mu$ using this algorithm (also in $O(\lambda + \mu)$ time and $O(1)$ space), but here is just the simplified version for finding the cycle at all.<br />
          The algorithm and returns true as soon as it detects a cycle.<br />
          If the sequence doesn’t have a cycle, then the function will never stop.<br />
          However this cannot happen during Pollard’s rho algorithm.</p>
        <pre><code className="has-line-data" data-line-start={272} data-line-end={280}>function floyd(f, x0):{"\n"}{"    "}tortoise = x0{"\n"}{"    "}hare = f(x0){"\n"}{"    "}while tortoise != hare:{"\n"}{"        "}tortoise = f(tortoise){"\n"}{"        "}hare = f(f(hare)){"\n"}{"    "}return true{"\n"}</code></pre>
        <h3 className="code-line" data-line-start={281} data-line-end={282}><a id="Implementation_281" />Implementation</h3>
        <p className="has-line-data" data-line-start={283} data-line-end={285}>First here is a implementation using the <strong>Floyd’s cycle-finding algorithm</strong>.<br />
          The algorithm runs (usually) in $O(\sqrt[4]{'{'}n{'}'} \log(n))$ time.</p>
        <pre><code className="has-line-data" data-line-start={287} data-line-end={308}><span className="hljs-function"><span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> <span className="hljs-title">mult</span><span className="hljs-params">(<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> a, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> b, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> mod)</span> </span>{"{"}{"\n"}{"    "}<span className="hljs-keyword">return</span> (__int128)a * b % mod;{"\n"}{"}"}{"\n"}{"\n"}<span className="hljs-function"><span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> <span className="hljs-title">f</span><span className="hljs-params">(<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> x, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> c, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> mod)</span> </span>{"{"}{"\n"}{"    "}<span className="hljs-keyword">return</span> (mult(x, x, mod) + c) % mod;{"\n"}{"}"}{"\n"}{"\n"}<span className="hljs-function"><span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> <span className="hljs-title">rho</span><span className="hljs-params">(<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> n, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> x0=<span className="hljs-number">2</span>, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> c=<span className="hljs-number">1</span>)</span> </span>{"{"}{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> x = x0;{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> y = x0;{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> g = <span className="hljs-number">1</span>;{"\n"}{"    "}<span className="hljs-keyword">while</span> (g == <span className="hljs-number">1</span>) {"{"}{"\n"}{"        "}x = f(x, c, n);{"\n"}{"        "}y = f(y, c, n);{"\n"}{"        "}y = f(y, c, n);{"\n"}{"        "}g = gcd(<span className="hljs-built_in">abs</span>(x - y), n);{"\n"}{"    "}{"}"}{"\n"}{"    "}<span className="hljs-keyword">return</span> g;{"\n"}{"}"}{"\n"}</code></pre>
        <p className="has-line-data" data-line-start={309} data-line-end={310}>The following table shows the values of $x$ and $y$ during the algorithm for $n = 2206637$, $x_0 = 2$ and $c = 1$.</p>
        <p className="has-line-data" data-line-start={311} data-line-end={327}>$$$$$$<br />
          \newcommand\T{'{'}\Rule{'{'}0pt{'}'}{'{'}1em{'}'}{'{'}.3em{'}'}{'}'}<br />
          \begin{'{'}array{'}'}{'{'}|l|l|l|l|l|l|{'}'}<br />
          \hline<br />
          i &amp; x_i \bmod n &amp; x_{'{'}2i{'}'} \bmod n &amp; x_i \bmod 317 &amp; x_{'{'}2i{'}'} \bmod 317 &amp; \gcd(x_i - x_{'{'}2i{'}'}, n) \\<br />
          \hline<br />
          0   &amp; 2       &amp; 2       &amp; 2       &amp; 2       &amp; -   \\<br />
          1   &amp; 5       &amp; 26      &amp; 5       &amp; 26      &amp; 1   \\<br />
          2   &amp; 26      &amp; 458330  &amp; 26      &amp; 265     &amp; 1   \\<br />
          3   &amp; 677     &amp; 1671573 &amp; 43      &amp; 32      &amp; 1   \\<br />
          4   &amp; 458330  &amp; 641379  &amp; 265     &amp; 88      &amp; 1   \\<br />
          5   &amp; 1166412 &amp; 351937  &amp; 169     &amp; 67      &amp; 1   \\<br />
          6   &amp; 1671573 &amp; 1264682 &amp; 32      &amp; 169     &amp; 1   \\<br />
          7   &amp; 2193080 &amp; 2088470 &amp; 74      &amp; 74      &amp; 317 \\<br />
          \hline<br />
          \end{'{'}array{'}'}$$$$$$</p>
        
        <p className="has-line-data" data-line-start={346} data-line-end={350}>As already noticed above: if $n$ is composite and the algorithm returns $n$ as factor, you have to repeat the procedure with different parameter $x_0$ and $c$.<br />
          E.g. the choice $x_0 = c = 1$ will not factor $25 = 5 \cdot 5$.<br />
          The algorithm will just return $25$.<br />
          However the choice $x_0 = 1$, $c = 2$ will factor it.</p>
        <h3 className="code-line" data-line-start={351} data-line-end={352}><a id="Brents_algorithm_351" />Brent’s algorithm</h3>
        <p className="has-line-data" data-line-start={353} data-line-end={357}>Brent uses a similar algorithm as Floyd.<br />
          It also uses two pointer.<br />
          But instead of advancing the pointers by one and two respectably, we advance them in powers of two.<br />
          As soon as $2^i$ is greater than $\lambda$ and $\mu$, we will find the cycle.</p>
        <pre><code className="has-line-data" data-line-start={359} data-line-end={372}>function floyd(f, x0):{"\n"}{"    "}tortoise = x0{"\n"}{"    "}hare = f(x0){"\n"}{"    "}l = 1{"\n"}{"    "}while tortoise != hare:{"\n"}{"        "}tortoise = hare{"\n"}{"        "}repeat l times:{"\n"}{"            "}hare = f(hare){"\n"}{"            "}if tortoise == hare:{"\n"}{"                "}return true{"\n"}{"        "}l *= 2{"\n"}{"    "}return true{"\n"}</code></pre>
        <p className="has-line-data" data-line-start={373} data-line-end={374}>Brent’s algorithm also runs in linear time, but is usually faster than Floyd’s algorithm, since it uses less evaluations of the function $f$.</p>
        <h3 className="code-line" data-line-start={375} data-line-end={376}><a id="Implementation_375" />Implementation</h3>
        <p className="has-line-data" data-line-start={377} data-line-end={379}>The straightforward implementation using Brent’s algorithms can be speeded up by noticing, that we can omit the terms $x_l - x_k$ if $k &lt; \frac{'{'}3 \cdot l{'}'}{'{'}2{'}'}$.<br />
          Also, instead of performing the $\gcd$ computation at every step, we multiply the terms and do it every few steps and backtrack if we overshoot.</p>
        <pre><code className="has-line-data" data-line-start={381} data-line-end={414}><span className="hljs-function"><span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> <span className="hljs-title">brent</span><span className="hljs-params">(<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> n, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> x0=<span className="hljs-number">2</span>, <span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> c=<span className="hljs-number">1</span>)</span> </span>{"{"}{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> x = x0;{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> g = <span className="hljs-number">1</span>;{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> q = <span className="hljs-number">1</span>;{"\n"}{"    "}<span className="hljs-keyword">long</span> <span className="hljs-keyword">long</span> xs, y;{"\n"}{"\n"}{"    "}<span className="hljs-keyword">int</span> m = <span className="hljs-number">128</span>;{"\n"}{"    "}<span className="hljs-keyword">int</span> l = <span className="hljs-number">1</span>;{"\n"}{"    "}<span className="hljs-keyword">while</span> (g == <span className="hljs-number">1</span>) {"{"}{"\n"}{"        "}y = x;{"\n"}{"        "}<span className="hljs-keyword">for</span> (<span className="hljs-keyword">int</span> i = <span className="hljs-number">1</span>; i &lt; l; i++){"\n"}{"            "}x = f(x, c, n);{"\n"}{"        "}<span className="hljs-keyword">int</span> k = <span className="hljs-number">0</span>;{"\n"}{"        "}<span className="hljs-keyword">while</span> (k &lt; l &amp;&amp; g == <span className="hljs-number">1</span>) {"{"}{"\n"}{"            "}xs = x;{"\n"}{"            "}<span className="hljs-keyword">for</span> (<span className="hljs-keyword">int</span> i = <span className="hljs-number">0</span>; i &lt; m &amp;&amp; i &lt; l - k; i++) {"{"}{"\n"}{"                "}x = f(x, c, n);{"\n"}{"                "}q = mult(q, <span className="hljs-built_in">abs</span>(y - x), n);{"\n"}{"            "}{"}"}{"\n"}{"            "}g = gcd(q, n);{"\n"}{"            "}k += m;{"\n"}{"        "}{"}"}{"\n"}{"        "}l *= <span className="hljs-number">2</span>;{"\n"}{"    "}{"}"}{"\n"}{"    "}<span className="hljs-keyword">if</span> (g == n) {"{"}{"\n"}{"        "}<span className="hljs-keyword">do</span> {"{"}{"\n"}{"            "}xs = f(xs, c, n);{"\n"}{"            "}g = gcd(<span className="hljs-built_in">abs</span>(xs - y), n);{"\n"}{"        "}{"}"} <span className="hljs-keyword">while</span> (g == <span className="hljs-number">1</span>);{"\n"}{"    "}{"}"}{"\n"}{"    "}<span className="hljs-keyword">return</span> g;{"\n"}{"}"}{"\n"}</code></pre>
        <p className="has-line-data" data-line-start={415} data-line-end={416}>The combination of a trial division for small prime numbers together with Brent’s version of Pollard’s rho algorithm will make a very powerful factorization algorithm.</p>
        <h2 className="code-line" data-line-start={417} data-line-end={418}><a id="Practice_Problems_417" />Practice Problems</h2>
        <ul>
          <li className="has-line-data" data-line-start={419} data-line-end={420}><a href="https://www.spoj.com/problems/FACT0/">SPOJ - FACT0</a></li>
          <li className="has-line-data" data-line-start={420} data-line-end={421}><a href="https://www.spoj.com/problems/FACT1/">SPOJ - FACT1</a></li>
          <li className="has-line-data" data-line-start={421} data-line-end={422}><a href="https://www.spoj.com/problems/FACT2/">SPOJ - FACT2</a></li>
          <li className="has-line-data" data-line-start={422} data-line-end={423}><a href="https://codeforces.com/gym/100753">GCPC 15 - Divisions</a></li>
        </ul>
        <h2 id="other-study-sources">Other Study Sources</h2>
        <ul>
          <li><a href="http://stackoverflow.com/questions/26344081/efficient-prime-factorization-for-large-numbers">Stackoverflow - Check Answers</a></li>
          <li><a href="https://www.amazon.com/Competitive-Programming-3rd-Steven-Halim/dp/B00FG8MNN8">Competitive Programming 3 by Steven &amp; Felix Halim - Page 212</a></li>
          <li><a href="https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/">GeeksForGeeks</a></li>
        </ul>
        </div>)